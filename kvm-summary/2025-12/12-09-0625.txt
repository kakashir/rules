From d62e82362 to caab494ce
KVM mailing list update from d62e82362 to caab494ce

Top 15 contributor Email domains (Based on Email Body)

      4 arm.com
      1 nvidia.com
      1 bytedance.com

Top 15 contributors (Based on Email Body)

      4  Sascha Bischoff <Sascha.Bischoff@arm.com>
      1  Max Gurtovoy <mgurtovoy@nvidia.com>
      1  "Jinhui Guo" <guojinhui.liam@bytedance.com>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  virtio: add driver_override support
[PATCH v2 1/1] virtio: add driver_override support
Author: Max Gurtovoy <mgurtovoy@nvidia.com>

Add support for the 'driver_override' attribute to Virtio devices. This
allows users to control which Virtio bus driver binds to a given Virtio
device.

If 'driver_override' is not set, the existing behavior is preserved and
devices will continue to auto-bind to the first matching Virtio bus
driver.

Tested with virtio blk device (virtio core and pci drivers are loaded):

  $ modprobe my_virtio_blk

  # automatically unbind from virtio_blk driver and override + bind to
  # my_virtio_blk driver.
  $ driverctl -v -b virtio set-override virtio0 my_virtio_blk

In addition, driverctl saves the configuration persistently under
/etc/driverctl.d/.

Signed-off-by: Avraham Evdaev <aevdaev@nvidia.com>
Signed-off-by: Max Gurtovoy <mgurtovoy@nvidia.com>
---

changes from v1:
 - use !strcmp() to compare strings (MST)
 - extend commit msg with example (MST)

---
 drivers/virtio/virtio.c | 34 ++++++++++++++++++++++++++++++++++
 include/linux/virtio.h  |  4 ++++
 2 files changed, 38 insertions(+)

----------------------------------------------------------------------

New:  Enable GICv5 Legacy CPUIF trapping & fix TDIR cap test
[PATCH 0/2] Enable GICv5 Legacy CPUIF trapping & fix TDIR cap test
Author: Sascha Bischoff <Sascha.Bischoff@arm.com>

These changes address two trapping-related issues when running legacy
(i.e. GICv3) guests on GICv5 hosts.

The first change enables the vgic_v3_cpuif_trap static branch on GICv5
hosts with legacy support, if trapping is required. The missing enable
was caught as part of debugging why UNDEFs were being injected into
guests when the ICH_HCR_EL2.TC bit was set - the expected bahaviour
was that KVM should handle the trapped accesses, with the guest
remaining blissfully unaware.

The second change fixes the specific cause of the TC bit being set in
the first place. The test for the ICH_HCR_EL2_TDIR cap was checking
for GICv3 CPUIF support and returning false prior to checking for
GICv5 Legacy support. The result was that on GICv5 hosts, the test
always returned false, and therefore the TC bit was being set. The
issue is fixed by reordering the checks to check for GICv5 Legacy
support first.

These changes are based against kvmarm/next.

Thanks,
Sascha

Sascha Bischoff (2):
  KVM: arm64: gic: Enable GICv3 CPUIF trapping on GICv5 hosts if
    required
  KVM: arm64: Correct test for ICH_HCR_EL2_TDIR cap for GICv5 hosts

 arch/arm64/kernel/cpufeature.c |  8 ++++----
 arch/arm64/kvm/vgic/vgic-v3.c  | 25 +++++++++++++++----------
 arch/arm64/kvm/vgic/vgic-v5.c  |  2 ++
 arch/arm64/kvm/vgic/vgic.h     |  1 +
 4 files changed, 22 insertions(+), 14 deletions(-)

----------------------------------------------------------------------

Exist: [PATCH 0/2] Enable GICv5 Legacy CPUIF trapping & fix TDIR cap test
 Skip: [PATCH 0/2] Enable GICv5 Legacy CPUIF trapping & fix TDIR cap test
New:  KVM: arm64: gic: Enable GICv3 CPUIF trapping on GICv5
[PATCH 1/2] KVM: arm64: gic: Enable GICv3 CPUIF trapping on GICv5
Author: Sascha Bischoff <Sascha.Bischoff@arm.com>

Factor out the enable (and printing of) the GICv3 CPUIF traps from the
main GICv3 probe into a separate function. Call said function from the
GICv5 probe for legacy support, ensuring that any required GICv3 CPUIF
traps on GICv5 hosts will be correctly handled, rather than injecting
an undef into the guest.

Signed-off-by: Sascha Bischoff <sascha.bischoff@arm.com>
---
 arch/arm64/kvm/vgic/vgic-v3.c | 25 +++++++++++++++----------
 arch/arm64/kvm/vgic/vgic-v5.c |  2 ++
 arch/arm64/kvm/vgic/vgic.h    |  1 +
 3 files changed, 18 insertions(+), 10 deletions(-)

----------------------------------------------------------------------

New:  vfio/pci: Skip hot reset on Link-Down
[PATCH] vfio/pci: Skip hot reset on Link-Down
Author: Jinhui Guo <guojinhui.liam@bytedance.com>

On hot-pluggable ports, simultaneous surprise removal of multiple
PCIe endpoints whether by pulling the card, powering it off, or
dropping the link can trigger a system deadlock.

Example: two PCIe endpoints are bound to vfio-pci and opened by
the same process (fdA for device A, fdB for device B).

1. A PCIe-fault brings B=E2=80=99s link down, then A=E2=80=99s.
2. The PCI core starts removing B:
   - pciehp_unconfigure_device() takes pci_rescan_remove_lock
   - vfio-pci=E2=80=99s remove routine waits for fdB to be closed
3. While B is stuck, the core removes A:
   - pciehp_ist() takes the read side of reset_lock A
   - It blocks on pci_rescan_remove_lock already held by B
4. Killing the process closes fdA first.
   vfio_pci_core_close_device() tries to hot-reset A, so it needs
   the write side of reset_lock A.
5. The write request sleeps until the read lock from step 3 is
   released, but that reader is itself waiting for B=E2=80=99s lock
   -> deadlock.

The stuck thread=E2=80=99s backtrace is as follows:
  /proc/1909/stack
    [<0>] vfio_unregister_group_dev+0x99/0xf0 [vfio]
    [<0>] vfio_pci_core_unregister_device+0x19/0xb0 [vfio_pci_core]
    [<0>] vfio_pci_remove+0x15/0x20 [vfio_pci]
    [<0>] pci_device_remove+0x3e/0xb0
    [<0>] device_release_driver_internal+0x19b/0x200
    [<0>] pci_stop_bus_device+0x6d/0x90
    [<0>] pci_stop_and_remove_bus_device+0xe/0x20
    [<0>] pciehp_unconfigure_device+0x8c/0x150
    [<0>] pciehp_disable_slot+0x68/0x140
    [<0>] pciehp_handle_presence_or_link_change+0x246/0x4c0
    [<0>] pciehp_ist+0x244/0x280
    [<0>] irq_thread_fn+0x1f/0x60
    [<0>] irq_thread+0x1ac/0x290
    [<0>] kthread+0xfa/0x240
    [<0>] ret_from_fork+0x209/0x260
    [<0>] ret_from_fork_asm+0x1a/0x30
  /proc/1910/stack
    [<0>] pciehp_unconfigure_device+0x43/0x150
    [<0>] pciehp_disable_slot+0x68/0x140
    [<0>] pciehp_handle_presence_or_link_change+0x246/0x4c0
    [<0>] pciehp_ist+0x244/0x280
    [<0>] irq_thread_fn+0x1f/0x60
    [<0>] irq_thread+0x1ac/0x290
    [<0>] kthread+0xfa/0x240
    [<0>] ret_from_fork+0x209/0x260
    [<0>] ret_from_fork_asm+0x1a/0x30
  /proc/6765/stack
    [<0>] pciehp_reset_slot+0x2c/0x70
    [<0>] pci_reset_hotplug_slot+0x3e/0x60
    [<0>] pci_reset_bus_function+0xcd/0x180
    [<0>] cxl_reset_bus_function+0xc8/0x110
    [<0>] __pci_reset_function_locked+0x4f/0xd0
    [<0>] vfio_pci_core_disable+0x381/0x400 [vfio_pci_core]
    [<0>] vfio_pci_core_close_device+0x63/0xd0 [vfio_pci_core]
    [<0>] vfio_df_close+0x48/0x80 [vfio]
    [<0>] vfio_df_group_close+0x32/0x70 [vfio]
    [<0>] vfio_device_fops_release+0x1d/0x40 [vfio]
    [<0>] __fput+0xe6/0x2b0
    [<0>] task_work_run+0x58/0x90
    [<0>] do_exit+0x29b/0xa80
    [<0>] do_group_exit+0x2c/0x80
    [<0>] get_signal+0x8f9/0x900
    [<0>] arch_do_signal_or_restart+0x29/0x210
    [<0>] exit_to_user_mode_loop+0x8e/0x4f0
    [<0>] do_syscall_64+0x262/0x630
    [<0>] entry_SYSCALL_64_after_hwframe+0x76/0x7e

Since the device is already disconnected, a hot-reset serves no
purpose and risks generating additional PCIe link errors during
the unplug sequence. Fix the issue by skipping hot-reset on Link-Down.

Signed-off-by: Jinhui Guo <guojinhui.liam@bytedance.com>
---
 drivers/vfio/pci/vfio_pci_core.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

----------------------------------------------------------------------

