From cc9eb1a2c to d3f09aab2
KVM mailing list update from cc9eb1a2c to d3f09aab2

Top 15 contributor Email domains (Based on Email Body)

     32 arm.com
     18 redhat.com
      2 intel.com
      2 google.com
      1 kernel.org

Top 15 contributors (Based on Email Body)

     32  Sascha Bischoff <Sascha.Bischoff@arm.com>
     18  Ani Sinha <anisinha@redhat.com>
      2  Marc Morcos <marcmorcos@google.com>
      1  Xiaoyao Li <xiaoyao.li@intel.com>
      1  Marc Zyngier <maz@kernel.org>
      1  Kevin Tian <kevin.tian@intel.com>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  KVM: arm64: Introduce vGIC-v5 with PPI support
[PATCH 00/32] KVM: arm64: Introduce vGIC-v5 with PPI support
Author: Sascha Bischoff <Sascha.Bischoff@arm.com>

This patch series adds the virtual GICv5 [1] device (vgic_v5). Only
PPIs are supported by this initial series, and the vgic_v5
implementation is restricted to the CPU interface, only. Further patch
series are to follow in due course, and will add support for SPIs,
LPIs, the GICv5 IRS, and the GICv5 ITS.

The main changes in this series are the following:

* Bump vgic_v3 to use generated ICH_VMCR_EL2 definitions
* Introduction of the vgic_v5 device, which can be created using the
  KVM_DEV_TYPE_ARM_VGIC_V5 device type
* GICv5 FGT handling, and trapping for guest accesses to
  ICC_IAFFIDR_EL1 and ICC_PPI_HMRx_EL1
* Introduction of queue_irq_unlock and set_pending_state to struct
  irq_ops
* Management of GICv5 PPI state & injection of PPIs
* Direct injection of PPIs using the GICv5 PPI DVI mechanism (used by
  the Arch Timer for mapped IRQs)
* Userspace injection of GICv5 interrupts via KVM_IRQ_LINE
* Addition of a simple GICv5 PPI selftest

As mentioned above, this series introduces two new irq_ops. The
reasoning for this is the following: GIGv5 doesn't have LRs, but
instead has the ICH_PPI_* registers which are able to manage the state
for all implemented vPPIs concurrently. Therefore, by carefully
managing the state of these, there is no need for per-VCPU AP lists
for GICv5. By using these new irq_ops, it becomes possible to directly
set vPPI pending state and to skip the enqueuing on AP lists.

One small, but noteworthy change is to KVM_IRQ_LINE. Previously,
KVM_IRQ_LINE has limited PPI injection to 16-31, inclusive, and SPI
injection to 32-1019, inclusive. When running with a vgic_v5, these
limits are now 0-127 and 0-65535, respectively. Note that technically
a GICv5 system could use up to 2^24 bits for the SPI ID space, but it
is expected that 65k should be sufficient for the foreseeable
future. If more are desired, it will require more significant changes
to KVM_IRQ_LINE.

One final thing to mention is the change to vgic_is_v3_compat(struct
kvm *kvm), which has now been extended to explicitly check that the
vgic_model is not v5. This was previously not required as native GICv5
guests didn't exist. This has a drawback: if called prior to
vgic_create, this check will return true on a GICv5 host with
FEAT_GCIE_LEGACY. This affects the initial state of the sanitized
system registers.

These changes have been tested on an Arm FVP with GICv5 support. A
guide on how to obtain this model and use it can be found at [2]. Note
that the 11.30 release is required as it adds the virtualisation
support.

Note: The first change in this series ("KVM: arm64: Account for RES1
bits in DECLARE_FEAT_MAP() and co") has been cherry-picked from Marc
Zyngier's VTCR sanitisation series [3], and adds support for RES1 FGT
bits. The reason for pulling in this change is that GICv5 adds a RES1
FGT bit, which needs to be correctly handled. Thanks for this change,
Marc!

The initial GICv5 KVM support was prototyped by myself and Timothy
Hayes. Timothy and I therefore have co-authorship on some of the
changes. Thanks for all of your efforts, Timothy!

These changes are based on torvalds/linux:master at 187d0801404f4. Any
future revisions of this series will be posted against the relevant
stable tags, but as we are close to 6.19-rc1 that didn't quite make
sense for this revision.

Thanks all for taking a look, and I look forward to your feedback!

Sascha

[1] https://developer.arm.com/documentation/aes0070/latest
[2] https://linaro.atlassian.net/wiki/x/CQAF-wY
[3] https://lore.kernel.org/all/20251210173024.561160-1-maz@kernel.org/

Marc Zyngier (1):
  KVM: arm64: Account for RES1 bits in DECLARE_FEAT_MAP() and co

Sascha Bischoff (31):
  KVM: arm64: gic-v3: Switch vGIC-v3 to use generated ICH_VMCR_EL2
  arm64/sysreg: Drop ICH_HFGRTR_EL2.ICC_HAPR_EL1 and make RES1
  arm64/sysreg: Add remaining GICv5 ICC_ & ICH_ sysregs for KVM support
  arm64/sysreg: Add GICR CDNMIA encoding
  KVM: arm64: gic-v5: Add ARM_VGIC_V5 device to KVM headers
  KVM: arm64: gic: Introduce interrupt type helpers
  KVM: arm64: gic-v5: Sanitize ID_AA64PFR2_EL1.GCIE
  KVM: arm64: gic-v5: Compute GICv5 FGTs on vcpu load
  KVM: arm64: gic-v5: Add emulation for ICC_IAFFID_EL1 accesses
  KVM: arm64: gic-v5: Trap and emulate ICH_PPI_HMRx_EL1 accesses
  KVM: arm64: gic: Set vgic_model before initing private IRQs
  KVM: arm64: gic-v5: Add vgic-v5 save/restore hyp interface
  KVM: arm64: gic-v5: Implement GICv5 load/put and save/restore
  KVM: arm64: gic-v5: Implement direct injection of PPIs
  KVM: arm64: gic: Introduce irq_queue and set_pending_state to irq_ops
  KVM: arm64: gic-v5: Implement PPI interrupt injection
  KVM: arm64: gic-v5: Check for pending PPIs
  KVM: arm64: gic-v5: Init Private IRQs (PPIs) for GICv5
  KVM: arm64: gic-v5: Support GICv5 interrupts with KVM_IRQ_LINE
  KVM: arm64: gic-v5: Create, init vgic_v5
  KVM: arm64: gic-v5: Reset vcpu state
  KVM: arm64: gic-v5: Bump arch timer for GICv5
  KVM: arm64: gic-v5: Mandate architected PPI for PMU emulation on GICv5
  KVM: arm64: gic: Hide GICv5 for protected guests
  KVM: arm64: gic-v5: Hide FEAT_GCIE from NV GICv5 guests
  KVM: arm64: gic-v5: Introduce kvm_arm_vgic_v5_ops and register them
  KVM: arm64: gic-v5: Set ICH_VCTLR_EL2.En on boot
  irqchip/gic-v5: Check if impl is virt capable
  KVM: arm64: gic-v5: Probe for GICv5 device
  Documentation: KVM: Introduce documentation for VGICv5
  KVM: arm64: selftests: Introduce a minimal GICv5 PPI selftest

 Documentation/virt/kvm/api.rst                |   6 +-
 .../virt/kvm/devices/arm-vgic-v5.rst          |  18 +
 arch/arm64/include/asm/el2_setup.h            |   3 +-
 arch/arm64/include/asm/kvm_asm.h              |   4 +
 arch/arm64/include/asm/kvm_host.h             |  20 +
 arch/arm64/include/asm/kvm_hyp.h              |   9 +
 arch/arm64/include/asm/sysreg.h               |  28 +-
 arch/arm64/include/asm/vncr_mapping.h         |   3 +
 arch/arm64/kvm/arch_timer.c                   | 116 +++-
 arch/arm64/kvm/arm.c                          |  25 +-
 arch/arm64/kvm/config.c                       | 133 ++++-
 arch/arm64/kvm/emulate-nested.c               | 123 ++++-
 arch/arm64/kvm/hyp/include/hyp/switch.h       |  27 +
 arch/arm64/kvm/hyp/nvhe/Makefile              |   2 +-
 arch/arm64/kvm/hyp/nvhe/hyp-main.c            |  32 ++
 arch/arm64/kvm/hyp/nvhe/switch.c              |  13 +
 arch/arm64/kvm/hyp/nvhe/sys_regs.c            |   8 +
 arch/arm64/kvm/hyp/vgic-v3-sr.c               |  64 +--
 arch/arm64/kvm/hyp/vgic-v5.c                  | 155 ++++++
 arch/arm64/kvm/hyp/vhe/Makefile               |   2 +-
 arch/arm64/kvm/nested.c                       |   5 +
 arch/arm64/kvm/pmu-emul.c                     |  20 +-
 arch/arm64/kvm/sys_regs.c                     |  86 ++-
 arch/arm64/kvm/vgic/vgic-init.c               | 119 +++--
 arch/arm64/kvm/vgic/vgic-kvm-device.c         |  74 ++-
 arch/arm64/kvm/vgic/vgic-mmio.c               |  28 +-
 arch/arm64/kvm/vgic/vgic-v3-nested.c          |   8 +-
 arch/arm64/kvm/vgic/vgic-v3.c                 |  48 +-
 arch/arm64/kvm/vgic/vgic-v5.c                 | 505 +++++++++++++++++-
 arch/arm64/kvm/vgic/vgic.c                    | 120 +++--
 arch/arm64/kvm/vgic/vgic.h                    |  76 ++-
 arch/arm64/tools/sysreg                       | 482 ++++++++++++++++-
 drivers/irqchip/irq-gic-v5-irs.c              |   4 +
 drivers/irqchip/irq-gic-v5.c                  |   5 +
 include/kvm/arm_arch_timer.h                  |   7 +-
 include/kvm/arm_pmu.h                         |   5 +-
 include/kvm/arm_vgic.h                        |  87 ++-
 include/linux/irqchip/arm-gic-v5.h            |  15 +
 include/linux/kvm_host.h                      |   1 +
 include/uapi/linux/kvm.h                      |   2 +
 tools/include/uapi/linux/kvm.h                |   2 +
 tools/testing/selftests/kvm/Makefile.kvm      |   1 +
 tools/testing/selftests/kvm/arm64/vgic_v5.c   | 248 +++++++++
 .../selftests/kvm/include/arm64/gic_v5.h      | 148 +++++
 44 files changed, 2623 insertions(+), 264 deletions(-)

----------------------------------------------------------------------

New:  KVM: arm64: Account for RES1 bits in DECLARE_FEAT_MAP()
[PATCH 01/32] KVM: arm64: Account for RES1 bits in DECLARE_FEAT_MAP()
Author: Sascha Bischoff <Sascha.Bischoff@arm.com>


None of the registers we manage in the feature dependency infrastructure
so far has any RES1 bit. This is about to change, as VTCR_EL2 has
its bit 31 being RES1.

In order to not fail the consistency checks by not describing a bit,
add RES1 bits to the set of immutable bits. This requires some extra
surgery for the FGT handling, as we now need to track RES1 bits there
as well.

There are no RES1 FGT bits *yet*. Watch this space.

Signed-off-by: Marc Zyngier <maz@kernel.org>
---
 arch/arm64/include/asm/kvm_host.h |  1 +
 arch/arm64/kvm/config.c           | 25 +++++++-------
 arch/arm64/kvm/emulate-nested.c   | 55 +++++++++++++++++--------------
 3 files changed, 45 insertions(+), 36 deletions(-)

----------------------------------------------------------------------

New:  i386/kvm: avoid installing duplicate msr entries in msr_handlers
[PATCH v1 01/28] i386/kvm: avoid installing duplicate msr entries in msr_handlers
Author: Ani Sinha <anisinha@redhat.com>

kvm_filter_msr() does not check if an msr entry is already present in the
msr_handlers table and installs a new handler unconditionally. If the function
is called again with the same MSR, it will result in duplicate entries in the
table and multiple such calls will fill up the table needlessly. Fix that.

Signed-off-by: Ani Sinha <anisinha@redhat.com>
---
 target/i386/kvm/kvm.c | 26 ++++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

----------------------------------------------------------------------

New:  vfio/pci: Disable qword access to the PCI ROM bar
[PATCH] vfio/pci: Disable qword access to the PCI ROM bar
Author: Kevin Tian <kevin.tian@intel.com>

Commit 2b938e3db335 ("vfio/pci: Enable iowrite64 and ioread64 for vfio
pci") enables qword access to the PCI bar resources. However certain
devices (e.g. Intel X710) are observed with problem upon qword accesses
to the rom bar, e.g. triggering PCI aer errors.

Instead of trying to identify all broken devices, universally disable
qword access to the rom bar i.e. going back to the old way which worked
reliably for years.

Reported-by: Farrah Chen <farrah.chen@intel.com>
Closes: https://bugzilla.kernel.org/show_bug.cgi?id=220740
Fixes: 2b938e3db335 ("vfio/pci: Enable iowrite64 and ioread64 for vfio pci")
Cc: stable@vger.kernel.org
Signed-off-by: Kevin Tian <kevin.tian@intel.com>
---
 drivers/vfio/pci/nvgrace-gpu/main.c |  4 ++--
 drivers/vfio/pci/vfio_pci_rdwr.c    | 19 +++++++++++++++----
 include/linux/vfio_pci_core.h       |  2 +-
 3 files changed, 18 insertions(+), 7 deletions(-)

----------------------------------------------------------------------

New:  qemu: TSAN Clean up
[PATCH 1/1] qemu: TSAN Clean up
Author: Marc Morcos <marcmorcos@google.com>

- Fix 3 thread races detected by tsan
- Change apicbase to 64 bit variable to reflect what it holds

Signed-off-by: Marc Morcos <marcmorcos@google.com>
---
 hw/i386/kvm/apic.c              | 12 ++++++++----
 hw/intc/apic_common.c           | 24 ++++++++++++++----------
 include/hw/i386/apic_internal.h |  2 +-
 monitor/monitor.c               |  8 +++++++-
 monitor/qmp.c                   |  2 ++
 target/i386/kvm/kvm.c           |  3 +++
 util/thread-pool.c              | 24 +++++++++++-------------
 7 files changed, 46 insertions(+), 29 deletions(-)

----------------------------------------------------------------------

New:  Clean up TSAN warnings
[PATCH 0/1] Clean up TSAN warnings
Author: Marc Morcos <marcmorcos@google.com>

When running several tests with tsan, thread races were detected when reading certain variables. This should allieviate the problem.
Additionally, the apicbase member of APICCommonState has been updated to 64 bit to reflect its contents.

Marc Morcos (1):
  qemu: TSAN Clean up

 hw/i386/kvm/apic.c              | 12 ++++++++----
 hw/intc/apic_common.c           | 24 ++++++++++++++----------
 include/hw/i386/apic_internal.h |  2 +-
 monitor/monitor.c               |  8 +++++++-
 monitor/qmp.c                   |  2 ++
 target/i386/kvm/kvm.c           |  3 +++
 util/thread-pool.c              | 24 +++++++++++-------------
 7 files changed, 46 insertions(+), 29 deletions(-)

----------------------------------------------------------------------

