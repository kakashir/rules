From 34c4ede9b to fa31e1d9a
KVM mailing list update from 34c4ede9b to fa31e1d9a

Top 15 contributor Email domains (Based on Email Body)

      9 google.com
      7 amd.com
      2 gmail.com
      1 redhat.com
      1 nutanix.com
      1 linux.ibm.com
      1 linux.dev
      1 kernel.org

Top 15 contributors (Based on Email Body)

      7  Sandipan Das <sandipan.das@amd.com>
      6  Sean Christopherson <seanjc@google.com>
      3  Raghavendra Rao Ananta <rananta@google.com>
      2  fuqiang wang <fuqiang.wng@gmail.com>
      1  Oliver Upton <oliver.upton@linux.dev>
      1  Marc Zyngier <maz@kernel.org>
      1  Jon Kohler <jon@nutanix.com>
      1  Jason Wang <jasowang@redhat.com>
      1  Janosch Frank <frankja@linux.ibm.com>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  KVM: SVM: Rename "fault_address" to "gpa" in npf_interception()
[PATCH 1/2] KVM: SVM: Rename "fault_address" to "gpa" in npf_interception()
Author: Sean Christopherson <seanjc@google.com>

Rename "fault_address" to "gpa" in KVM's #NPF handler and track it as a
gpa_t to more precisely document what type of address is being captured,
and because "gpa" is much more succinct.

No functional change intended.

Signed-off-by: Sean Christopherson <seanjc@google.com>
---
 arch/x86/kvm/svm/svm.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

----------------------------------------------------------------------

New:  KVM: SVM: Add fast MMIO bus writes
[PATCH 0/2] KVM: SVM: Add fast MMIO bus writes
Author: Sean Christopherson <seanjc@google.com>

Add support for expediting fast MMIO bus writes in SVM's npt_interception()
to match VMX's support in handle_ept_misconfig().

I don't recall what prompted me to write the patches; I suspect it was a
"well, why not?" situation.  They've been sitting in one of my bajillion
branches since May, and I rediscovered them while looking for something
else.

Sean Christopherson (2):
  KVM: SVM: Rename "fault_address" to "gpa" in npf_interception()
  KVM: SVM: Add support for expedited writes to the fast MMIO bus

 arch/x86/kvm/svm/svm.c | 29 +++++++++++++++++++++++++----
 1 file changed, 25 insertions(+), 4 deletions(-)

----------------------------------------------------------------------

New:  KVM: x86: WARN if hrtimer callback for periodic APIC
[PATCH v6 1/4] KVM: x86: WARN if hrtimer callback for periodic APIC
Author: Sean Christopherson <seanjc@google.com>

WARN and don't restart the hrtimer if KVM's callback runs with the guest's
APIC timer in periodic mode but with a period of '0', as not advancing the
hrtimer's deadline would put the CPU into an infinite loop of hrtimer
events.  Observing a period of '0' should be impossible, even when the
hrtimer is running on a different CPU than the vCPU, as KVM is supposed to
cancel the hrtimer before changing (or zeroing) the period, e.g. when
switching from periodic to one-shot.

Cc: stable@vger.kernel.org
Signed-off-by: Sean Christopherson <seanjc@google.com>
---
 arch/x86/kvm/lapic.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

----------------------------------------------------------------------

New:  KVM: x86: Fix hard lockup with periodic timer in guest
[PATCH v6 0/4] KVM: x86: Fix hard lockup with periodic timer in guest
Author: Sean Christopherson <seanjc@google.com>

fuqiang's patch/series to fix a bug in KVM's local APIC timer emulation where
it can trigger a hard lockup due to restarting an hrtimer with an expired
deadline over and over (and over).

v6:
 - Split the apic_timer_fn() change to a separate patch (mainly for a
   bisection point).
 - Handle (and WARN on) period=0 in apic_timer_fn().
 - Add a patch to grab a pointer to the kvm_timer struct locally.
 - Tag the fixes (and prep work) for stable@.

v5:
 - https://lore.kernel.org/all/20251107034802.39763-1-fuqiang.wng@gmail.com
 - Add more details in commit messages and letters.

v4:
 - https://lore.kernel.org/all/20251105135340.33335-1-fuqiang.wng@gmail.com
 - merge two patch into one

v3:
 - https://lore.kernel.org/all/20251022150055.2531-1-fuqiang.wng@gmail.com
 - Fix: advanced SW timer (hrtimer) expiration does not catch up to current
   time.
 - optimize the commit message of patch 2

v2:
 - https://lore.kernel.org/all/20251021154052.17132-1-fuqiang.wng@gmail.com
 - Added a bugfix for hardlockup in v2

v1: https://lore.kernel.org/all/20251013125117.87739-1-fuqiang.wng@gmail.com

Sean Christopherson (2):
  KVM: x86: WARN if hrtimer callback for periodic APIC timer fires with
    period=0
  KVM: x86: Grab lapic_timer in a local variable to cleanup periodic
    code

fuqiang wang (2):
  KVM: x86: Explicitly set new periodic hrtimer expiration in
    apic_timer_fn()
  KVM: x86: Fix VM hard lockup after prolonged inactivity with periodic
    HV timer

 arch/x86/kvm/lapic.c | 44 +++++++++++++++++++++++++++++++-------------
 1 file changed, 31 insertions(+), 13 deletions(-)

----------------------------------------------------------------------

New:  KVM: arm64: GICv3: Check the implementation before accessing ICH_VTR_EL2
[PATCH] KVM: arm64: GICv3: Check the implementation before accessing ICH_VTR_EL2
Author: Marc Zyngier <maz@kernel.org>

The ICH_HCR_EL2 patching code is generally GIC implementation agnostic,
except when checking for broken Apple HW, which imposes to read
ICH_VTR_EL2.

It is therefore important to check whether we are running on such
HW before reading this register, as it will otherwise UNDEF when
run on HW that doesn't have GICv3.

Reported-by: Marek Szyprowski <m.szyprowski@samsung.com>
Tested-by: Marek Szyprowski <m.szyprowski@samsung.com>
Fixes: ca30799f7c2d ("KVM: arm64: Turn vgic-v3 errata traps into a patched-in constant")
Closes: https://lore.kernel.org/r/b618732b-fd26-49e0-84c5-bfd54be09cd2@samsung.com
Signed-off-by: Marc Zyngier <maz@kernel.org>
---
 arch/arm64/kvm/vgic/vgic-v3.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

----------------------------------------------------------------------

New:  perf: Add a capability for hardware virtualized PMUs
[RFC PATCH 1/7] perf: Add a capability for hardware virtualized PMUs
Author: Sandipan Das <sandipan.das@amd.com>

Introduce PERF_PMU_CAP_VIRTUALIZED_VPMU as an extension to the existing
PERF_PMU_CAP_MEDIATED_VPMU to indicate support for hardware virtualized
PMU where the guest counter states are automatically saved and restored
during world switches.

Pass on the new capability through x86_pmu_cap so that any other entity,
such as KVM, can enquire if the host has hardware PMU virtualization.

Signed-off-by: Sandipan Das <sandipan.das@amd.com>
---
 arch/x86/events/core.c            | 1 +
 arch/x86/include/asm/perf_event.h | 1 +
 include/linux/perf_event.h        | 1 +
 3 files changed, 3 insertions(+)

----------------------------------------------------------------------

New:  KVM: SVM: Support for PMC virtualization
[RFC PATCH 0/7] KVM: SVM: Support for PMC virtualization
Author: Sandipan Das <sandipan.das@amd.com>

AMD Zen 5 processors introduced PMC virtualization. When the feature is
enabled, hardware can restore and save the guest PMU state at VM-Entry
and VM-Exit respectively. The host PMU state still needs to be managed
by software and this is done with the help of the Mediated PMU framework
which can schedule the host perf events in or out.

This feature is documented under Section 15.39 in Volume 2 of the AMD64
Architecture Programmerâ€™s Manual which can be found below.
https://bugzilla.kernel.org/attachment.cgi?id=306250

The guest PMU state is saved in the VMCB. Hence, struct kvm_pmu goes out
of sync and does not have the latest PMU state. In some cases, such as
during event filtering or instruction emulation, the VMCB needs to be
accessed for reading or writing the current register state. This is done
using host-initiated MSR accesses but the method may not be ideal and
perhaps requires additional PMU ops to be introduced. The goal is to
have data in vendor-specific structures like VMCB functions accessible
to some of the common KVM x86 PMU functions.

Any feedback is appreciated.

Patch Summary
  * The first three patches add new feature bits and capability flags
    to detect and advertise support for hardware PMU virtualization.
  * The fourth patch extends Mediated PMU to make use of hardware PMU
    virtualization.
  * The remaining patches add the vendor-specific changes for PMC
    virtualization.

TODOs
  * Add appropriate KVM PMU ops to access MSR states from the VMCB.
  * Make MSR states in the VMCB accessible via KVM_{GET,SET}_MSRS.
  * Support for SEV-ES and SEV-SNP guests.
  * Support for nested guests (nSVM).
  * Support for the IRPerfCount register which is a free-running
    instructions retired counter.

Testing
  * Used three different guest PMU configurations.
    * PerfMonV2 capable - 6 counters with Global Control and Status
      registers (Zen 4 and later).
    * PerfCtrExtCore capable - 6 counters but no Global Control and
      Status registers (Zen 3 and older).
    * Legacy Guest - 4 counters only (pre-Zen, older than Family 15h).
  * KVM Unit Tests passed.
  * Perf Fuzzer passed.

The patches should be applied over v5 of the Mediated PMU series [1]
along with an RDPMC interception fix [2].

[1] https://lore.kernel.org/all/20250806195706.1650976-1-seanjc@google.com/
[2] https://lore.kernel.org/all/aN1vfykNs8Dmv_g0@google.com/

Sandipan Das (7):
  perf: Add a capability for hardware virtualized PMUs
  x86/cpufeatures: Add PerfCtrVirt feature bit
  perf/x86/amd/core: Set PERF_PMU_CAP_VIRTUALIZED_VPMU
  KVM: x86/pmu: Add support for hardware virtualized PMUs
  KVM: SVM: Add VMCB fields for PMC virtualization
  KVM: SVM: Add support for PMC virtualization
  KVM: SVM: Adjust MSR index for legacy guests

 arch/x86/events/amd/core.c         |   3 +
 arch/x86/events/core.c             |   1 +
 arch/x86/include/asm/cpufeatures.h |   1 +
 arch/x86/include/asm/perf_event.h  |   1 +
 arch/x86/include/asm/svm.h         |  12 ++-
 arch/x86/kvm/pmu.c                 |  94 ++++++++++++++++++-----
 arch/x86/kvm/pmu.h                 |   6 ++
 arch/x86/kvm/svm/pmu.c             | 115 +++++++++++++++++++++++++++++
 arch/x86/kvm/svm/svm.c             |  52 +++++++++++++
 arch/x86/kvm/svm/svm.h             |   1 +
 arch/x86/kvm/vmx/pmu_intel.c       |   1 +
 arch/x86/kvm/x86.c                 |   4 +
 arch/x86/kvm/x86.h                 |   1 +
 include/linux/perf_event.h         |   1 +
 14 files changed, 273 insertions(+), 20 deletions(-)

----------------------------------------------------------------------

New:  KVM: arm64: Only drop references on empty tables in stage2_free_walker
[PATCH 1/3] KVM: arm64: Only drop references on empty tables in stage2_free_walker
Author: Raghavendra Rao Ananta <rananta@google.com>


A subsequent change to the way KVM frees stage-2s will invoke the free
walker on sub-ranges of the VM's IPA space, meaning there's potential
for only partially visiting a table's PTEs.

Split the leaf and table visitors and only drop references on a table
when the page count reaches 1, implying there are no valid PTEs that
need to be visited. Invalidate the table PTE to avoid traversing the
stale reference.

Signed-off-by: Oliver Upton <oliver.upton@linux.dev>
---
 arch/arm64/kvm/hyp/pgtable.c | 38 ++++++++++++++++++++++++++++++------
 1 file changed, 32 insertions(+), 6 deletions(-)

----------------------------------------------------------------------

New:  KVM: arm64: Reschedule as needed when destroying the
[PATCH 0/3] KVM: arm64: Reschedule as needed when destroying the
Author: Raghavendra Rao Ananta <rananta@google.com>

Hello,

When destroying a fully-mapped 128G VM abruptly, the following scheduler
warning is observed:

  sched: CPU 0 need_resched set for > 100018840 ns (100 ticks) without schedule
  CPU: 0 UID: 0 PID: 9617 Comm: kvm_page_table_ Tainted: G O 6.16.0-smp-DEV #3 NONE
  Tainted: [O]=OOT_MODULE
  Call trace:
      show_stack+0x20/0x38 (C)
      dump_stack_lvl+0x3c/0xb8
      dump_stack+0x18/0x30
      resched_latency_warn+0x7c/0x88
      sched_tick+0x1c4/0x268
      update_process_times+0xa8/0xd8
      tick_nohz_handler+0xc8/0x168
      __hrtimer_run_queues+0x11c/0x338
      hrtimer_interrupt+0x104/0x308
      arch_timer_handler_phys+0x40/0x58
      handle_percpu_devid_irq+0x8c/0x1b0
      generic_handle_domain_irq+0x48/0x78
      gic_handle_irq+0x1b8/0x408
      call_on_irq_stack+0x24/0x30
      do_interrupt_handler+0x54/0x78
      el1_interrupt+0x44/0x88
      el1h_64_irq_handler+0x18/0x28
      el1h_64_irq+0x84/0x88
      stage2_free_walker+0x30/0xa0 (P)
      __kvm_pgtable_walk+0x11c/0x258
      __kvm_pgtable_walk+0x180/0x258
      __kvm_pgtable_walk+0x180/0x258
      __kvm_pgtable_walk+0x180/0x258
      kvm_pgtable_walk+0xc4/0x140
      kvm_pgtable_stage2_destroy+0x5c/0xf0
      kvm_free_stage2_pgd+0x6c/0xe8
      kvm_uninit_stage2_mmu+0x24/0x48
      kvm_arch_flush_shadow_all+0x80/0xa0
      kvm_mmu_notifier_release+0x38/0x78
      __mmu_notifier_release+0x15c/0x250
      exit_mmap+0x68/0x400
      __mmput+0x38/0x1c8
      mmput+0x30/0x68
      exit_mm+0xd4/0x198
      do_exit+0x1a4/0xb00
      do_group_exit+0x8c/0x120
      get_signal+0x6d4/0x778
      do_signal+0x90/0x718
      do_notify_resume+0x70/0x170
      el0_svc+0x74/0xd8
      el0t_64_sync_handler+0x60/0xc8
      el0t_64_sync+0x1b0/0x1b8

The host kernel was running with CONFIG_PREEMPT_NONE=y, and since the
page-table walk operation takes considerable amount of time for a VM
with such a large number of PTEs mapped, the warning is seen.

To mitigate this, split the walk into smaller ranges, by checking for
cond_resched() between each range. Since the path is executed during
VM destruction, after the page-table structure is unlinked from the
KVM MMU, relying on cond_resched_rwlock_write() isn't necessary.

Patch-1 kills the assumption that the page-table hierarchy under the
table is free (in stage2_free_walker()). Instead, drop and clear the
references only on empty tables.

Patch-2 splits the kvm_pgtable_stage2_destroy() function into separate
'walk' and 'free PGD' parts.

Patch-3 leverages the split and performs the walk periodically over
smaller ranges and calls cond_resched() between them.

The series was originally posted and merged [1], but was later reverted
due to syzkaller catching a UAF bug [2]. This series fixes the issue, and
the original need_resched warning is addressed.

[1]: https://lore.kernel.org/all/175582091313.1266576.4329884314263043118.b4-ty@linux.dev/
[2]: https://lore.kernel.org/all/20250910180930.3679473-1-oliver.upton@linux.dev/ 

Oliver Upton (1):
  KVM: arm64: Only drop references on empty tables in stage2_free_walker

Raghavendra Rao Ananta (2):
  KVM: arm64: Split kvm_pgtable_stage2_destroy()
  KVM: arm64: Reschedule as needed when destroying the stage-2
    page-tables

 arch/arm64/include/asm/kvm_pgtable.h | 30 +++++++++++++
 arch/arm64/include/asm/kvm_pkvm.h    |  4 +-
 arch/arm64/kvm/hyp/pgtable.c         | 63 +++++++++++++++++++++++-----
 arch/arm64/kvm/mmu.c                 | 36 +++++++++++++++-
 arch/arm64/kvm/pkvm.c                | 11 ++++-
 5 files changed, 129 insertions(+), 15 deletions(-)

----------------------------------------------------------------------

