From 895136b5a to 686659896
KVM mailing list update from 895136b5a to 686659896

Top 15 contributor Email domains (Based on Email Body)

      3 intel.com
      3 amazon.co.uk
      1 linux.alibaba.com
      1 infradead.org

Top 15 contributors (Based on Email Body)

      3  David Woodhouse <dwmw@amazon.co.uk>
      3  Adrian Hunter <adrian.hunter@intel.com>
      1  Fangyu Yu <fangyu.yu@linux.alibaba.com>
      1  David Woodhouse <dwmw2@infradead.org>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  KVM: TDX: Disable general support for MWAIT in guest
[PATCH RFC 1/2] KVM: TDX: Disable general support for MWAIT in guest
Author: Adrian Hunter <adrian.hunter@intel.com>

TDX support for using the MWAIT instruction in a guest has issues, so
disable it for now.

Background

Like VMX, TDX can allow the MWAIT instruction to be executed in a guest.
Unlike VMX, TDX cannot necessarily provide for virtualization of MSRs that
a guest might reasonably expect to exist as well.

For example, in the case of a Linux guest, the default idle driver
intel_idle may access MSR_POWER_CTL or MSR_PKG_CST_CONFIG_CONTROL.  To
virtualize those, KVM would need the guest not to enable #VE reduction,
which is not something that KVM can control or even be aware of.  Note,
however, that the consequent unchecked MSR access errors might be harmless.

Without #VE reduction enabled, the TDX Module will inject #VE for MSRs that
it does not virtualize itself.  The guest can then hypercall the host VMM
for a resolution.

With #VE reduction enabled, accessing MSRs such as the 2 above, results in
the TDX Module injecting #GP.

Currently, Linux guest opts for #VE reduction unconditionally if it is
available, refer reduce_unnecessary_ve().  However, the #VE reduction
feature was not added to the TDX Module until versions 1.5.09 and 2.0.04.
Refer https://github.com/intel/tdx-module/releases

There is also a further issue experienced by a Linux guest.  Prior to
TDX Module versions 1.5.09 and 2.0.04, the Always-Running-APIC-Timer (ARAT)
feature (CPUID leaf 6: EAX bit 2) is not exposed.  That results in cpuidle
disabling the timer interrupt and invoking the Tick Broadcast framework
to provide a wake-up.  Currently, that falls back to the PIT timer which
does not work for TDX, resulting in the guest becoming stuck in the idle
loop.

Conclusion

User's may expect TDX support of MWAIT in a guest to be similar to VMX
support, but KVM cannot ensure that.  Consequently KVM should not expose
the capability.

Fixes: 0186dd29a2518 ("KVM: TDX: add ioctl to initialize VM with TDX specific parameters")
Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
---
 arch/x86/include/asm/kvm_host.h |  2 ++
 arch/x86/kvm/vmx/tdx.c          | 22 +++++++++++++++++++++-
 arch/x86/kvm/x86.c              |  8 +++++---
 3 files changed, 28 insertions(+), 4 deletions(-)

----------------------------------------------------------------------

New:  KVM: TDX: MWAIT in guest
[PATCH RFC 0/2] KVM: TDX: MWAIT in guest
Author: Adrian Hunter <adrian.hunter@intel.com>

Hi

TDX support for using the MWAIT instruction in a guest has issues.

One option is just to disable it, see patch 1.

Then perhaps provide a distinct way to enable it, documenting the
limitations TDX has compared with VMX in this regard, so that users
will be made aware of the limitations.  See patch 2.

Other options:
1. Do nothing but document the limitations.
2. Patch 1 but not patch 2; look for a better solution


Adrian Hunter (2):
      KVM: TDX: Disable general support for MWAIT in guest
      KVM: TDX: Add flag to support MWAIT instruction only

 Documentation/virt/kvm/x86/intel-tdx.rst | 28 ++++++++++-
 arch/x86/include/asm/kvm_host.h          |  2 +
 arch/x86/include/uapi/asm/kvm.h          |  3 ++
 arch/x86/kvm/vmx/tdx.c                   | 80 +++++++++++++++++++++++++-------
 arch/x86/kvm/x86.c                       |  8 ++--
 5 files changed, 98 insertions(+), 23 deletions(-)

----------------------------------------------------------------------

New:  KVM: x86: Restore caching of KVM CPUID base
[PATCH v2 1/3] KVM: x86: Restore caching of KVM CPUID base
Author: David Woodhouse <dwmw2@infradead.org>


This mostly reverts commit a5b32718081e ("KVM: x86: Remove unnecessary
caching of KVM's PV CPUID base").

Sure, caching state which might change has certain risks, but KVM
already does cache the CPUID contents, and the whole point of calling
kvm_apply_cpuid_pv_features_quirk() from kvm_vcpu_after_set_cpuid() is
to cache the contents of that leaf too, so that guest_pv_has() can
access them quickly.

An upcoming commit is going to want to use vcpu->arch.kvm_cpuid from
kvm_cpuid() at runtime too, so put it back.

Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
---
 arch/x86/include/asm/kvm_host.h |  1 +
 arch/x86/kvm/cpuid.c            | 16 +++++++++++-----
 2 files changed, 12 insertions(+), 5 deletions(-)

----------------------------------------------------------------------

New:  Support "generic" CPUID timing leaf as KVM guest and host
[PATCH v2 0/3] Support "generic" CPUID timing leaf as KVM guest and host
Author: David Woodhouse <dwmw2@infradead.org>

In https://lkml.org/lkml/2008/10/1/246 VMware proposed a generic standard
for harmonising CPUID between hypervisors. It was mostly shot down in
flames, but the generic timing leaf at 0x4000_0010 didn't quite die.

Mostly the hypervisor leaves at 0x4000_0xxx are very hypervisor-specific,
but XNU and FreeBSD as guests will look for 0x4000_0010 unconditionally,
under any hypervisor. The EC2 Nitro hypervisor has also exposed TSC
frequency information in this leaf, since 2020.

As things stand, KVM guests have to reverse-calculate the TSC frequency
from the mul/shift information given to them in the KVM clock to convert
ticks into nanoseconds, with a corresponding loss of precision.

There's certainly no way we can sanely use 0x4000_0010 for anything *else*
at this point. Just adopt it, as both guest and host. We already have the
infrastructure for keeping the TSC frequency information up to date for
the Xen CPUID leaf anyway, so do precisely the same for this one.

v2:
  â€¢ Fix inadvertent C++ism pointed out by syzbot:
    https://ci.syzbot.org/series/a9510b1a-8024-41ce-9775-675f5c165e20

David Woodhouse (3):
      KVM: x86: Restore caching of KVM CPUID base
      KVM: x86: Provide TSC frequency in "generic" timing infomation CPUID leaf
      x86/kvm: Obtain TSC frequency from CPUID if present

 arch/x86/include/asm/kvm_host.h      |  1 +
 arch/x86/include/asm/kvm_para.h      |  1 +
 arch/x86/include/uapi/asm/kvm_para.h | 11 +++++++++++
 arch/x86/kernel/kvm.c                | 10 ++++++++++
 arch/x86/kernel/kvmclock.c           |  7 ++++++-
 arch/x86/kvm/cpuid.c                 | 23 ++++++++++++++++++-----
 6 files changed, 47 insertions(+), 6 deletions(-)

----------------------------------------------------------------------

New:  RISC-V: KVM: Write hgatp register with valid mode bits
[PATCH] RISC-V: KVM: Write hgatp register with valid mode bits
Author: fangyu.yu <fangyu.yu@linux.alibaba.com>


According to the RISC-V Privileged Architecture Spec, when MODE=Bare
is selected,software must write zero to the remaining fields of hgatp.

We have detected the valid mode supported by the HW before, So using a
valid mode to detect how many vmid bits are supported.

Signed-off-by: Fangyu Yu <fangyu.yu@linux.alibaba.com>
---
 arch/riscv/kvm/vmid.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

----------------------------------------------------------------------

