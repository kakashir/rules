From 3f66ad8a2 to a9e8ec3e3
KVM mailing list update from 3f66ad8a2 to a9e8ec3e3

Top 15 contributor Email domains (Based on Email Body)

      8 linux.ibm.com
      4 redhat.com
      1 kernel.org
      1 intel.com
      1 grsecurity.net
      1 gmail.com

Top 15 contributors (Based on Email Body)

      7  Farhan Ali <alifm@linux.ibm.com>
      4  Maxim Levitsky <mlevitsk@redhat.com>
      1  Wangyang Guo <wangyang.guo@intel.com>
      1  Mathias Krause <minipli@grsecurity.net>
      1  Marc Zyngier <maz@kernel.org>
      1  Janosch Frank <frankja@linux.ibm.com>
      1  Gopi Krishna Menon <krishnagopi487@gmail.com>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  KVM: x86: Warn if KVM tries to deliver an #APF completion when APF is not enabled
[PATCH 1/3] KVM: x86: Warn if KVM tries to deliver an #APF completion when APF is not enabled
Author: Maxim Levitsky <mlevitsk@redhat.com>

KVM flushes the APF queue completely when the asynchronous pagefault is
disabled, therefore this case should not occur.

Signed-off-by: Maxim Levitsky <mlevitsk@redhat.com>
---
 arch/x86/kvm/x86.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

----------------------------------------------------------------------

New:  Fix a lost async pagefault notification when the guest is using SMM
[PATCH 0/3] Fix a lost async pagefault notification when the guest is using SMM
Author: Maxim Levitsky <mlevitsk@redhat.com>

Recently we debugged a customer case in which the guest VM was showing=0D
tasks permanently stuck in the kvm_async_pf_task_wait_schedule.=0D
=0D
This was traced to the incorrect flushing of the async pagefault queue,=0D
which was done during the real mode entry by the kvm_post_set_cr0.=0D
=0D
This code, the kvm_clear_async_pf_completion_queue does wait for all #APF=0D
tasks to complete but then it proceeds to wipe the 'done' queue without=0D
notifying the guest.=0D
=0D
Such approach is acceptable if the guest is being rebooted or if=0D
it decided to disable APF, but it leads to failures if the entry to real=0D
mode was caused by SMM, because in this case the guest intends to continue=
=0D
using APF after returning from the SMM handler.=0D
=0D
Amusingly, and on top of this, the SMM entry code doesn't call=0D
the kvm_set_cr0 (and subsequently neither it calls kvm_post_set_cr0),=0D
but rather only the SMM mode exit code does.=0D
=0D
During SMM entry, the SMM code calls .set_cr0 instead, with an intention=0D
to bypass various architectural checks that can otherwise fail.=0D
=0D
One example of such check is a #GP check on an attempt to disable paging=0D
while the long mode is active.=0D
To do this, the user must first exit to the compatibility mode and only the=
n=0D
disable paging.=0D
=0D
The question of the possiblity of eliminating this bypass, is a side topic=
=0D
that is probably worth discussing separately.=0D
=0D
Back to the topic, the kvm_set_cr0 is still called during SMM handling,=0D
more particularly during the exit from SMM, by emulator_leave_smm:=0D
=0D
It is called once with CR0.PE =3D=3D off, to setup a baseline real-mode=0D
environment, and then a second time, with the original CR0 value.=0D
=0D
Even more amusingly, usually both mentioned calls result in APF queue being=
=0D
flushed, because the code in kvm_post_set_cr0 doesn't distinguish between=0D
entry and exit from protected mode, and SMM mode usually enables protection=
=0D
and paging, and exits itself without bothering first to exit back to=0D
the real mode.=0D
=0D
To fix this problem, I think the best solution is to drop the call to=0D
kvm_clear_async_pf_completion_queue in kvm_post_set_cr0 code altogether,=0D
and instead raise the KVM_REQ_APF_READY, when the protected mode=0D
is re-established.=0D
=0D
Existing APF requests should have no problem to complete while the guest is=
=0D
in SMM and the APF completion event injection should work too,=0D
because SMM handler *ought* to not enable interrupts because otherwise=0D
things would go south very quickly.=0D
=0D
This change also brings the logic to be up to date with logic that KVM=0D
follows when the guest disables APIC.=0D
KVM also raises KVM_REQ_APF_READY when the APIC is re-enabled.=0D
=0D
In addition to this, I also included few fixes for few semi-theortical=0D
bugs I found while debugging this.=0D
=0D
Best regards,=0D
        Maxim Levitsky=0D
=0D
Maxim Levitsky (3):=0D
  KVM: x86: Warn if KVM tries to deliver an #APF completion when APF is=0D
    not enabled=0D
  KVM: x86: Fix a semi theoretical bug in=0D
    kvm_arch_async_page_present_queued=0D
  KVM: x86: Fix the interaction between SMM and the asynchronous=0D
    pagefault=0D
=0D
 arch/x86/kvm/x86.c | 22 +++++++++++++++-------=0D
 arch/x86/kvm/x86.h |  1 +=0D
 2 files changed, 16 insertions(+), 7 deletions(-)=0D

----------------------------------------------------------------------

New:  s390/pci: Restore airq unconditionally for the zPCI device
[PATCH v1 1/6] s390/pci: Restore airq unconditionally for the zPCI device
Author: Farhan Ali <alifm@linux.ibm.com>

Commit c1e18c17bda6 ("s390/pci: add zpci_set_irq()/zpci_clear_irq()"),
introduced the zpci_set_irq() and zpci_clear_irq(), to be used while
resetting a zPCI device.

Commit da995d538d3a ("s390/pci: implement reset_slot for hotplug slot"),
mentions zpci_clear_irq() being called in the path for zpci_hot_reset_device().
But that is not the case anymore and these functions are not called
outside of this file.

However after a CLP disable/enable reset (zpci_hot_reset_device),
the airq setup of the device will need to be restored. Since we
are no longer calling zpci_clear_airq() in the reset path, we should
restore the airq for device unconditionally.

Signed-off-by: Farhan Ali <alifm@linux.ibm.com>
---
 arch/s390/pci/pci_irq.c | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

----------------------------------------------------------------------

New:  Error recovery for vfio-pci devices on s390x
[PATCH v1 0/6] Error recovery for vfio-pci devices on s390x
Author: Farhan Ali <alifm@linux.ibm.com>

Hi,

This Linux kernel patch series introduces support for error recovery for
passthrough PCI devices on System Z (s390x). 

Background
----------
For PCI devices on s390x an operating system receives platform specific 
error events from firmware rather than through AER.Today for
passthrough/userspace devices, we don't attempt any error recovery
and ignore any error events for the devices. The passthrough/userspace devices are 
managed by the vfio-pci driver. The driver does register error handling 
callbacks (error_detected), and on an error trigger an eventfd to userspace. 
But we need a mechanism to notify userspace (QEMU/guest/userspace drivers) about
the error event. 

Proposal
--------
We can expose this error information (currently only the PCI Error Code) via a 
device specific memory region for s390 vfio pci devices. Userspace can then read 
the memory region to obtain the error information and take appropriate actions
such as driving a device reset. The memory region provides some flexibility in 
providing more information in the future if required.

I would appreciate some feedback on this approach.

Thanks
Farhan

Farhan Ali (6):
  s390/pci: Restore airq unconditionally for the zPCI device
  s390/pci: Update the logic for detecting passthrough device
  s390/pci: Store PCI error information for passthrough devices
  vfio-pci/zdev: Setup a zpci memory region for error information
  vfio-pci/zdev: Perform platform specific function reset for zPCI
  vfio: Allow error notification and recovery for ISM device

 arch/s390/include/asm/pci.h       |  29 +++++++
 arch/s390/pci/pci.c               |   2 +
 arch/s390/pci/pci_event.c         | 107 ++++++++++++++-----------
 arch/s390/pci/pci_irq.c           |   3 +-
 drivers/vfio/pci/vfio_pci_core.c  |  22 +++++-
 drivers/vfio/pci/vfio_pci_intrs.c |   2 +-
 drivers/vfio/pci/vfio_pci_priv.h  |   8 ++
 drivers/vfio/pci/vfio_pci_zdev.c  | 126 +++++++++++++++++++++++++++++-
 include/uapi/linux/vfio.h         |   2 +
 include/uapi/linux/vfio_zdev.h    |   5 ++
 10 files changed, 253 insertions(+), 53 deletions(-)

----------------------------------------------------------------------

New:  KVM: arm64: Correctly populate FAR_EL2 on nested SEA injection
[PATCH] KVM: arm64: Correctly populate FAR_EL2 on nested SEA injection
Author: Marc Zyngier <maz@kernel.org>

vcoy_write_sys_reg()'s signature is not totally obvious, and it
is rather easy to write something that looks correct, except that...
Oh wait...

Swap addr and FAR_EL2 to restore some sanity in the nested SEA
department.

Fixes: 9aba641b9ec2a ("KVM: arm64: nv: Respect exception routing rules for SEAs")
Signed-off-by: Marc Zyngier <maz@kernel.org>
---
 arch/arm64/kvm/emulate-nested.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

----------------------------------------------------------------------

New:  KVM: selftests: fix minor typo in cpumodel_subfuncs
[PATCH] KVM: selftests: fix minor typo in cpumodel_subfuncs
Author: Gopi Krishna Menon <krishnagopi487@gmail.com>

Specifically, fix spelling of "available" in main function.

Signed-off-by: Gopi Krishna Menon <krishnagopi487@gmail.com>
---
 tools/testing/selftests/kvm/s390/cpumodel_subfuncs_test.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

----------------------------------------------------------------------

New:  Documentation: kvm: Fix ordering
[PATCH] Documentation: kvm: Fix ordering
Author: Janosch Frank <frankja@linux.ibm.com>

7.43 has been assigned twice, make
KVM_CAP_ARM_CACHEABLE_PFNMAP_SUPPORTED 7.44.

Signed-off-by: Janosch Frank <frankja@linux.ibm.com>
Fixes: f55ce5a6cd33 ("KVM: arm64: Expose new KVM cap for cacheable PFNMAP")
---

Wanted to rebase a patch that introduces a new capaiblity but the
resulting conflict looked suspicious.

---
 Documentation/virt/kvm/api.rst | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

----------------------------------------------------------------------

