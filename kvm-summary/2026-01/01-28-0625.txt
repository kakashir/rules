From 9b9a1fd8d to f6c35d288
KVM mailing list update from 9b9a1fd8d to f6c35d288

Top 15 contributor Email domains (Based on Email Body)

     31 redhat.com
     13 kernel.org
      5 amazon.com
      4 loongson.cn
      3 amd.com
      2 gmail.com
      1 tu-dortmund.de
      1 linux.ibm.com

Top 15 contributors (Based on Email Body)

     19  Ani Sinha <anisinha@redhat.com>
     13  "Mike Rapoport (Microsoft)" <rppt@kernel.org>
     12  Oliver Steffen <osteffen@redhat.com>
      5  Nikita Kalyazin <kalyazin@amazon.com>
      4  Bibo Mao <maobibo@loongson.cn>
      3  Kim Phillips <kim.phillips@amd.com>
      2  Jiakai Xu <jiakaipeanut@gmail.com>
      1  Simon Schippers <simon.schippers@tu-dortmund.de>
      1  Shivaprasad G Bhat <sbhat@linux.ibm.com>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  userfaultfd: introduce mfill_copy_folio_locked() helper
[PATCH RFC 01/17] userfaultfd: introduce mfill_copy_folio_locked() helper
Author: Mike Rapoport <rppt@kernel.org>


Split copying of data when locks held from mfill_atomic_pte_copy() into
a helper function mfill_copy_folio_locked().

This makes improves code readability and makes complex
mfill_atomic_pte_copy() function easier to comprehend.

No functional change.

Signed-off-by: Mike Rapoport (Microsoft) <rppt@kernel.org>
---
 mm/userfaultfd.c | 59 ++++++++++++++++++++++++++++--------------------
 1 file changed, 35 insertions(+), 24 deletions(-)

----------------------------------------------------------------------

New:  mm, kvm: allow uffd suppot in guest_memfd
[PATCH RFC 00/17] mm, kvm: allow uffd suppot in guest_memfd
Author: Mike Rapoport <rppt@kernel.org>


Hi,

These patches enable support for userfaultfd in guest_memfd.
They are quite different from the latest posting [1] so I'm restarting the
versioning. As there was a lot of tension around the topic, this is an RFC
to get some feedback and see how we can move forward.

As the ground work I refactored userfaultfd handling of PTE-based memory types
(anonymous and shmem) and converted them to use vm_uffd_ops for allocating a
folio or getting an existing folio from the page cache. shmem also implements
callbacks that add a folio to the page cache after the data passed in
UFFDIO_COPY was copied and remove the folio from the page cache if page table
update fails.

In order for guest_memfd to notify userspace about page faults, there are new
VM_FAULT_UFFD_MINOR and VM_FAULT_UFFD_MISSING that a ->fault() handler can
return to inform the page fault handler that it needs to call
handle_userfault() to complete the fault.

Nikita helped to plumb these new goodies into guest_memfd and provided basic
tests to verify that guest_memfd works with userfaultfd.

I deliberately left hugetlb out, at least for the most part.
hugetlb handles acquisition of VMA and more importantly establishing of parent
page table entry differently than PTE-based memory types. This is a different
abstraction level than what vm_uffd_ops provides and people objected to
exposing such low level APIs as a part of VMA operations.

Also, to enable uffd in guest_memfd refactoring of hugetlb is not needed and I
prefer to delay it until the dust settles after the changes in this set.

[1] https://lore.kernel.org/all/20251130111812.699259-1-rppt@kernel.org

Mike Rapoport (Microsoft) (12):
  userfaultfd: introduce mfill_copy_folio_locked() helper
  userfaultfd: introduce struct mfill_state
  userfaultfd: introduce mfill_get_pmd() helper.
  userfaultfd: introduce mfill_get_vma() and mfill_put_vma()
  userfaultfd: retry copying with locks dropped in mfill_atomic_pte_copy()
  userfaultfd: move vma_can_userfault out of line
  userfaultfd: introduce vm_uffd_ops
  userfaultfd, shmem: use a VMA callback to handle UFFDIO_CONTINUE
  userfaultfd: introduce vm_uffd_ops->alloc_folio()
  shmem, userfaultfd: implement shmem uffd operations using vm_uffd_ops
  userfaultfd: mfill_atomic() remove retry logic
  mm: introduce VM_FAULT_UFFD_MINOR fault reason

Nikita Kalyazin (5):
  mm: introduce VM_FAULT_UFFD_MISSING fault reason
  KVM: guest_memfd: implement userfaultfd minor mode
  KVM: guest_memfd: implement userfaultfd missing mode
  KVM: selftests: test userfaultfd minor for guest_memfd
  KVM: selftests: test userfaultfd missing for guest_memfd

 include/linux/mm.h                            |   5 +
 include/linux/mm_types.h                      |  15 +-
 include/linux/shmem_fs.h                      |  14 -
 include/linux/userfaultfd_k.h                 |  74 +-
 mm/hugetlb.c                                  |  21 +
 mm/memory.c                                   |   8 +-
 mm/shmem.c                                    | 188 +++--
 mm/userfaultfd.c                              | 671 ++++++++++--------
 .../testing/selftests/kvm/guest_memfd_test.c  | 191 +++++
 virt/kvm/guest_memfd.c                        | 134 +++-
 10 files changed, 871 insertions(+), 450 deletions(-)

----------------------------------------------------------------------

New:  LoongArch: KVM: Add FPU delay load support
[PATCH v2 0/3] LoongArch: KVM: Add FPU delay load support
Author: Bibo Mao <maobibo@loongson.cn>

FPU is lazy enabled in KVM hypervisor. After FPU is enabled and loaded,
vCPU can be preempted and FPU will be lost, there will be FPU exception
and FPU load again.

Here FPU is delay load until guest enter entry.

---
v1 ... v2:
  1. Keep funtion trace_kvm_aux() with FPU restore called still, only
     remove preempt disable/enable API call.
  2. Use one KVM_REQ_FPU_LOAD request bit and add fpu_load_type int
     type, remove KVM_REQ_LSX_LOAD/KVM_REQ_LASX_LOAD request bit
---
Bibo Mao (3):
  LoongArch: KVM: Move LSX capability check in LSX exception handler
  LoongArch: KVM: Move LASX capability check in LASX exception handler
  LoongArch: KVM: Add FPU delay load support

 arch/loongarch/include/asm/kvm_host.h |  2 ++
 arch/loongarch/kvm/exit.c             | 15 ++++++++---
 arch/loongarch/kvm/vcpu.c             | 39 ++++++++++++++-------------
 3 files changed, 35 insertions(+), 21 deletions(-)

----------------------------------------------------------------------

New:  LoongArch: KVM: Move LSX capability check in LSX exception handler
[PATCH v2 1/3] LoongArch: KVM: Move LSX capability check in LSX exception handler
Author: Bibo Mao <maobibo@loongson.cn>

Like FPU exception handler, check LSX capability in LSX exception
handler rather than kvm_own_lsx(). LSX capability in function
kvm_guest_has_lsx() implies FPU capability in kvm_guest_has_fpu(),
only check kvm_guest_has_lsx() is ok here.

Signed-off-by: Bibo Mao <maobibo@loongson.cn>
---
 arch/loongarch/kvm/exit.c | 4 +++-
 arch/loongarch/kvm/vcpu.c | 3 ---
 2 files changed, 3 insertions(+), 4 deletions(-)

----------------------------------------------------------------------

New:  hw/acpi: Make BIOS linker optional
[PATCH v5 1/6] hw/acpi: Make BIOS linker optional
Author: Oliver Steffen <osteffen@redhat.com>

Make the BIOS linker optional in acpi_table_end() and calculate the ACPI
table checksum directly if no linker is provided.

This makes it possible to call for example
acpi_build_madt() from outside the ACPI table builder context.

Signed-off-by: Oliver Steffen <osteffen@redhat.com>
---
 hw/acpi/aml-build.c | 29 +++++++++++++++++++++++++++--
 1 file changed, 27 insertions(+), 2 deletions(-)

----------------------------------------------------------------------

New:  igvm: Supply MADT via IGVM parameter
[PATCH v5 0/6] igvm: Supply MADT via IGVM parameter
Author: Oliver Steffen <osteffen@redhat.com>

When launching using an IGVM file, supply a copy of the MADT (part of the ACPI
tables) via an IGVM parameter (IGVM_VHY_MADT) to the guest, in addition to the
regular fw_cfg mechanism.

The IGVM parameter can be consumed by Coconut SVSM [1], instead of relying on
the fw_cfg interface, which has caused problems before due to unexpected access
[2,3]. Using IGVM parameters is the default way for Coconut SVSM; switching
over would allow removing specialized code paths for QEMU in Coconut.

Coconut SVSM needs to know the SMP configuration, but does not look at
any other ACPI data, nor does it interact with the PCI bus settings.
Since the MADT is static and not linked with other ACPI tables, it can
be supplied stand-alone like this.

Generating the MADT twice (IGVM processing and ACPI table building) seems
acceptable, since there is no infrastructure to obtain the MADT out of the ACPI
table memory area during IGVM processing.

In any case OVMF, which runs after SVSM has already been initialized, will
continue reading all ACPI tables via fw_cfg and provide fixed up ACPI data to
the OS as before.

This series makes ACPI table building more generic by making the BIOS linker
optional. This allows the MADT to be generated outside of the ACPI build
context. A new function (acpi_build_madt_standalone()) is added for that. With
that, the IGVM MADT parameter field can be filled with the MADT data during
processing of the IGVM file.

[1] https://github.com/coconut-svsm/svsm/pull/858
[2] https://gitlab.com/qemu-project/qemu/-/issues/2882
[3] https://github.com/coconut-svsm/svsm/issues/646

v5:
- Rebase on latest IGVM rework series from Gerd
- Make qigvm_find_parameter_entry() more generic and use everywhere possible;
  It now takes the index as input, instead of the full parameter struct
- Consistently use early returns when looking up parameter entries
- Emit a warning message if no parameter area can be found for a given index

v4:
- Add ACPI table checksum calculation without BIOS linker, used
  for the standalone MADT.
- Don't pass ConfidentialGuestState into the IGVM backend anymore.
  Not needed, since we already have the full MachineState there now.
- Move the NULL check patch out into a new series (to be posted).
- Address remaining cleanup comments.

v3:
- Pass the machine state into IGVM file processing context instead of MADT data
- Generate MADT from inside the IGVM backend
- Refactor: Extract common code for finding IGVM parameter from IGVM parameter handlers
- Add NULL pointer check for igvm_get_buffer()

v2:
- Provide more context in the message of the main commit
- Document the MADT parameter of IgvmCfgClass::process()
- Document why no MADT data is provided the process call in sev.c

Based-on: <20260126123755.357378-1-kraxel@redhat.com>
Signed-off-by: Oliver Steffen <osteffen@redhat.com>

Oliver Steffen (6):
  hw/acpi: Make BIOS linker optional
  hw/acpi: Add standalone function to build MADT
  igvm: Add common function for finding parameter entries
  igvm: Refactor qigvm_parameter_insert
  igvm: Pass machine state to IGVM file processing
  igvm: Fill MADT IGVM parameter field

 backends/igvm-cfg.c       |   2 +-
 backends/igvm.c           | 255 +++++++++++++++++++++++---------------
 hw/acpi/aml-build.c       |  29 ++++-
 hw/i386/acpi-build.c      |   9 ++
 hw/i386/acpi-build.h      |   2 +
 include/system/igvm-cfg.h |   3 +-
 include/system/igvm.h     |   5 +-
 target/i386/sev.c         |   3 +-
 8 files changed, 197 insertions(+), 111 deletions(-)

----------------------------------------------------------------------

Exist: [PATCH v5 1/6] hw/acpi: Make BIOS linker optional
 Skip: [PATCH v5 1/6] hw/acpi: Make BIOS linker optional
Exist: [PATCH v5 0/6] igvm: Supply MADT via IGVM parameter
 Skip: [PATCH v5 0/6] igvm: Supply MADT via IGVM parameter
Exist: [PATCH v5 1/6] hw/acpi: Make BIOS linker optional
 Skip: [PATCH v5 1/6] hw/acpi: Make BIOS linker optional
Exist: [PATCH v5 0/6] igvm: Supply MADT via IGVM parameter
 Skip: [PATCH v5 0/6] igvm: Supply MADT via IGVM parameter
New:  RISC-V: KVM: Skip IMSIC update if vCPU IMSIC state is not initialized
[PATCH] RISC-V: KVM: Skip IMSIC update if vCPU IMSIC state is not initialized
Author: Jiakai Xu <jiakaipeanut@gmail.com>

kvm_riscv_vcpu_aia_imsic_update() assumes that the vCPU IMSIC state has
already been initialized and unconditionally accesses imsic->vsfile_lock.
However, in fuzzed ioctl sequences, the AIA device may be initialized at
the VM level while the per-vCPU IMSIC state is still NULL.

This leads to invalid access when entering the vCPU run loop before
IMSIC initialization has completed.

The crash manifests as:
  Unable to handle kernel paging request at virtual address
  dfffffff00000006
  ...
  kvm_riscv_vcpu_aia_imsic_update arch/riscv/kvm/aia_imsic.c:801
  kvm_riscv_vcpu_aia_update arch/riscv/kvm/aia_device.c:493
  kvm_arch_vcpu_ioctl_run arch/riscv/kvm/vcpu.c:927
  ...

Add a guard to skip the IMSIC update path when imsic_state is NULL. This
allows the vCPU run loop to continue safely.

This issue was discovered during fuzzing of RISC-V KVM code.

Fixes: db8b7e97d6137a ("RISC-V: KVM: Add in-kernel virtualization of AIA IMSIC")
Signed-off-by: Jiakai Xu <xujiakai2025@iscas.ac.cn>
Signed-off-by: Jiakai Xu <jiakaiPeanut@gmail.com>
---
 arch/riscv/kvm/aia_imsic.c | 4 ++++
 1 file changed, 4 insertions(+)

----------------------------------------------------------------------

New:  RISC-V: KVM: Fix null pointer dereference in kvm_riscv_aia_imsic_rw_attr()
[PATCH] RISC-V: KVM: Fix null pointer dereference in kvm_riscv_aia_imsic_rw_attr()
Author: Jiakai Xu <jiakaipeanut@gmail.com>

Add a null pointer check for imsic_state before dereferencing it in
kvm_riscv_aia_imsic_rw_attr(). While the function checks that the
vcpu exists, it doesn't verify that the vcpu's imsic_state has been
initialized, leading to a null pointer dereference when accessed.

The crash manifests as:
  Unable to handle kernel paging request at virtual address
  dfffffff00000006
  ...
  kvm_riscv_aia_imsic_rw_attr+0x2d8/0x854 arch/riscv/kvm/aia_imsic.c:958
  aia_set_attr+0x2ee/0x1726 arch/riscv/kvm/aia_device.c:354
  kvm_device_ioctl_attr virt/kvm/kvm_main.c:4744 [inline]
  kvm_device_ioctl+0x296/0x374 virt/kvm/kvm_main.c:4761
  vfs_ioctl fs/ioctl.c:51 [inline]
  ...

The fix adds a check to return -ENODEV if imsic_state is NULL and moves 
isel assignment after imsic_state NULL check.

Fixes: 5463091a51cfaa ("RISC-V: KVM: Expose IMSIC registers as attributes of AIA irqchip")
Signed-off-by: Jiakai Xu <xujiakai2025@iscas.ac.cn>
Signed-off-by: Jiakai Xu <jiakaiPeanut@gmail.com>
---
 arch/riscv/kvm/aia_imsic.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

----------------------------------------------------------------------

New:  i386/kvm: avoid installing duplicate msr entries in msr_handlers
[PATCH v3 01/33] i386/kvm: avoid installing duplicate msr entries in msr_handlers
Author: Ani Sinha <anisinha@redhat.com>

kvm_filter_msr() does not check if an msr entry is already present in the
msr_handlers table and installs a new handler unconditionally. If the function
is called again with the same MSR, it will result in duplicate entries in the
table and multiple such calls will fill up the table needlessly. Fix that.

Signed-off-by: Ani Sinha <anisinha@redhat.com>
---
 target/i386/kvm/kvm.c | 26 ++++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

----------------------------------------------------------------------

New:  KVM: SEV: IBPB-on-Entry guest support
[PATCH 1/2] KVM: SEV: IBPB-on-Entry guest support
Author: Kim Phillips <kim.phillips@amd.com>

The SEV-SNP IBPB-on-Entry feature does not require a guest-side
implementation. The feature was added in Zen5 h/w, after the first
SNP Zen implementation, and thus was not accounted for when the
initial set of SNP features were added to the kernel.

In its abundant precaution, commit 8c29f0165405 ("x86/sev: Add SEV-SNP
guest feature negotiation support") included SEV_STATUS' IBPB-on-Entry
bit as a reserved bit, thereby masking guests from using the feature.

Unmask the bit, to allow guests to take advantage of the feature on
hypervisor kernel versions that support it: Amend the SEV_STATUS MSR
SNP_RESERVED_MASK to exclude bit 23 (IbpbOnEntry).

Fixes: 8c29f0165405 ("x86/sev: Add SEV-SNP guest feature negotiation support")
Cc: Nikunj A Dadhania <nikunj@amd.com>
Cc: Tom Lendacky <thomas.lendacky@amd.com>
CC: Borislav Petkov (AMD) <bp@alien8.de>
CC: Michael Roth <michael.roth@amd.com>
Cc: stable@kernel.org
Signed-off-by: Kim Phillips <kim.phillips@amd.com>
---
 arch/x86/boot/compressed/sev.c   | 1 +
 arch/x86/coco/sev/core.c         | 1 +
 arch/x86/include/asm/msr-index.h | 5 ++++-
 3 files changed, 6 insertions(+), 1 deletion(-)

----------------------------------------------------------------------

New:  KVM: SEV: Add support for IBPB-on-Entry
[PATCH 0/2] KVM: SEV: Add support for IBPB-on-Entry
Author: Kim Phillips <kim.phillips@amd.com>

AMD EPYC 5th generation and above processors support IBPB-on-Entry
for SNP guests.  By invoking an Indirect Branch Prediction Barrier
(IBPB) on VMRUN, old indirect branch predictions are prevented
from influencing indirect branches within the guest.

The first patch is guest-side support which unmasks the Zen5+ feature
bit to allow kernel guests to set the feature.

The second patch is host-side support that checks the CPUID and
then sets the feature bit in the VMSA supported features mask.

Based on https://github.com/kvm-x86/linux kvm-x86/next
(kvm-x86-next-2026.01.23, e81f7c908e16).

This series also available here:

https://github.com/AMDESE/linux/tree/ibpb-on-entry-latest

Advance qemu bits (to add ibpb-on-entry=on/off switch) available here:

https://github.com/AMDESE/qemu/tree/ibpb-on-entry-latest

Qemu bits will be posted upstream once kernel bits are merged.
They depend on Naveen Rao's "target/i386: SEV: Add support for
enabling VMSA SEV features":

https://lore.kernel.org/qemu-devel/cover.1761648149.git.naveen@kernel.org/

Kim Phillips (2):
  KVM: SEV: IBPB-on-Entry guest support
  KVM: SEV: Add support for IBPB-on-Entry

 arch/x86/boot/compressed/sev.c     | 1 +
 arch/x86/coco/sev/core.c           | 1 +
 arch/x86/include/asm/cpufeatures.h | 1 +
 arch/x86/include/asm/msr-index.h   | 5 ++++-
 arch/x86/include/asm/svm.h         | 1 +
 arch/x86/kvm/svm/sev.c             | 9 ++++++++-
 6 files changed, 16 insertions(+), 2 deletions(-)

----------------------------------------------------------------------

