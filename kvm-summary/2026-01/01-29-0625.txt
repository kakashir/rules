From f6c35d288 to 78a137aae
KVM mailing list update from f6c35d288 to 78a137aae

Top 15 contributor Email domains (Based on Email Body)

     36 arm.com
      7 google.com
      5 loongson.cn
      2 thorondor.fr
      1 tu-dortmund.de
      1 redhat.com
      1 kernel.org
      1 fb.com

Top 15 contributors (Based on Email Body)

     36  Sascha Bischoff <Sascha.Bischoff@arm.com>
      7  Sean Christopherson <seanjc@google.com>
      5  Bibo Mao <maobibo@loongson.cn>
      2  Thomas Courrege <thomas.courrege@thorondor.fr>
      1  Ted Logan <tedlogan@fb.com>
      1  Simon Schippers <simon.schippers@tu-dortmund.de>
      1  "Michael S. Tsirkin" <mst@redhat.com>
      1  Marc Zyngier <maz@kernel.org>

===== Patch list in this time period =====


===== Patch Commit Messages ====

New:  KVM: SEV: Add KVM_SEV_SNP_HV_REPORT_REQ command
[PATCH v6 1/1] KVM: SEV: Add KVM_SEV_SNP_HV_REPORT_REQ command
Author: Thomas Courrege <thomas.courrege@thorondor.fr>

Add support for retrieving the SEV-SNP attestation report via the
SNP_HV_REPORT_REQ firmware command and expose it through a new KVM
ioctl for SNP guests.

Signed-off-by: Thomas Courrege <thomas.courrege@thorondor.fr>
---
 .../virt/kvm/x86/amd-memory-encryption.rst    | 28 +++++++++
 arch/x86/include/uapi/asm/kvm.h               |  9 +++
 arch/x86/kvm/svm/sev.c                        | 63 +++++++++++++++++++
 drivers/crypto/ccp/sev-dev.c                  |  1 +
 include/linux/psp-sev.h                       | 31 +++++++++
 5 files changed, 132 insertions(+)

----------------------------------------------------------------------

Exist: [PATCH v6 1/1] KVM: SEV: Add KVM_SEV_SNP_HV_REPORT_REQ command
 Skip: [PATCH v6 0/1] KVM: SEV: Add KVM_SEV_SNP_HV_REPORT_REQ command
New:  vfio: selftests: fix format conversion compiler warning
[PATCH] vfio: selftests: fix format conversion compiler warning
Author: Ted Logan <tedlogan@fb.com>

Use the standard format conversion macro PRIx64 to generate the
appropriate format conversion for 64-bit integers. Fixes a compiler
warning with -Wformat on i386.

Signed-off-by: Ted Logan <tedlogan@fb.com>
Reported-by: kernel test robot <lkp@intel.com>
Closes: https://lore.kernel.org/oe-kbuild-all/202601211830.aBEjmEFD-lkp@i=
ntel.com/

---
Compiler warning fixed by patch:

   In file included from tools/testing/selftests/vfio/lib/include/libvfio=
.h:6:
   tools/testing/selftests/vfio/lib/include/libvfio/iommu.h:49:2: warning=
: format specifies type 'unsigned long' but the argument has type 'u64' (=
aka 'unsigned long long') [-Wformat]
      49 |         VFIO_ASSERT_EQ(__iommu_unmap(iommu, region, NULL), 0);
         |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   tools/testing/selftests/vfio/lib/include/libvfio/assert.h:32:37: note:=
 expanded from macro 'VFIO_ASSERT_EQ'
      32 | #define VFIO_ASSERT_EQ(_a, _b, ...) VFIO_ASSERT_OP(_a, _b, =3D=
=3D, ##__VA_ARGS__)
         |                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~=
~~~~~~~~~~~~~~~
   tools/testing/selftests/vfio/lib/include/libvfio/assert.h:27:22: note:=
 expanded from macro 'VFIO_ASSERT_OP'
      26 |         fprintf(stderr, "  Observed: %#lx %s %#lx\n",         =
                  \
         |                                              ~~~~
      27 |                         (u64)__lhs, #_op, (u64)__rhs);        =
                  \
         |                                           ^~~~~~~~~~

---
 tools/testing/selftests/vfio/lib/include/libvfio/assert.h | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

----------------------------------------------------------------------

New:  KVM: arm64: Account for RES1 bits in
[PATCH v4 01/36] KVM: arm64: Account for RES1 bits in
Author: Sascha Bischoff <Sascha.Bischoff@arm.com>


None of the registers we manage in the feature dependency infrastructure
so far has any RES1 bit. This is about to change, as VTCR_EL2 has
its bit 31 being RES1.

In order to not fail the consistency checks by not describing a bit,
add RES1 bits to the set of immutable bits. This requires some extra
surgery for the FGT handling, as we now need to track RES1 bits there
as well.

There are no RES1 FGT bits *yet*. Watch this space.

Signed-off-by: Marc Zyngier <maz@kernel.org>
Signed-off-by: Sascha Bischoff <sascha.bischoff@arm.com>
Reviewed-by: Jonathan Cameron <jonathan.cameron@huawei.com>
---
 arch/arm64/include/asm/kvm_host.h |  1 +
 arch/arm64/kvm/config.c           | 25 +++++++-------
 arch/arm64/kvm/emulate-nested.c   | 55 +++++++++++++++++--------------
 3 files changed, 45 insertions(+), 36 deletions(-)

----------------------------------------------------------------------

New:  KVM: arm64: Introduce vGIC-v5 with PPI support
[PATCH v4 00/36] KVM: arm64: Introduce vGIC-v5 with PPI support
Author: Sascha Bischoff <Sascha.Bischoff@arm.com>

This is the v4 of the patch series to add the virtual GICv5 [1] device
(vgic_v5). Only PPIs are supported by this initial series, and the
vgic_v5 implementation is restricted to the CPU interface,
only. Further patch series are to follow in due course, and will add
support for SPIs, LPIs, the GICv5 IRS, and the GICv5 ITS.

v1, v2, and v3 of this series can be found at [2], [3], [4], respectively.

Main changes since v3:

* Re-worked the impl PPI detection to limit it to those KVM can use
  (Timers, PMU, SW_PPI). Timers and SW_PPI are always present, and
  PMUIRQ is if the host has a PMUv3.
* Moved to calculating the PPI Pending state on guest entry to avoid
  potential races with userspace PPI injection. This is much less
  expensive now that we limit the subset of PPIs exposed to the guest.
* Added Reviewed-by tags

The following is still outstanding:

* Allow for sparse PPI state storage (e.g., xarrays). Given that most
  of the 128 potential PPIs will never be used with a guest, it is
  extremely wasteful to allocate storage for them.

These changes are based on v6.19-rc7. As before, the first commit has
been cherry-picked from Marc's VTCR sanitisation series [5].

Thanks all for the feedback!

Sascha

[1] https://developer.arm.com/documentation/aes0070/latest
[2] https://lore.kernel.org/all/20251212152215.675767-1-sascha.bischoff@arm=
.com/
[3] https://lore.kernel.org/all/20251219155222.1383109-1-sascha.bischoff@ar=
m.com/
[4] https://lore.kernel.org/all/20260109170400.1585048-1-sascha.bischoff@ar=
m.com/
[5] https://lore.kernel.org/all/20251210173024.561160-1-maz@kernel.org/

Marc Zyngier (1):
  KVM: arm64: Account for RES1 bits in DECLARE_FEAT_MAP() and co

Sascha Bischoff (35):
  KVM: arm64: gic-v3: Switch vGIC-v3 to use generated ICH_VMCR_EL2
  arm64/sysreg: Drop ICH_HFGRTR_EL2.ICC_HAPR_EL1 and make RES1
  arm64/sysreg: Add remaining GICv5 ICC_ & ICH_ sysregs for KVM support
  arm64/sysreg: Add GICR CDNMIA encoding
  KVM: arm64: gic: Set vgic_model before initing private IRQs
  KVM: arm64: gic-v5: Add ARM_VGIC_V5 device to KVM headers
  KVM: arm64: gic: Introduce interrupt type helpers
  KVM: arm64: gic-v5: Add Arm copyright header
  KVM: arm64: gic-v5: Detect implemented PPIs on boot
  KVM: arm64: gic-v5: Sanitize ID_AA64PFR2_EL1.GCIE
  KVM: arm64: gic-v5: Support GICv5 FGTs & FGUs
  KVM: arm64: gic-v5: Add emulation for ICC_IAFFIDR_EL1 accesses
  KVM: arm64: gic-v5: Add vgic-v5 save/restore hyp interface
  KVM: arm64: gic-v5: Implement GICv5 load/put and save/restore
  KVM: arm64: gic-v5: Implement direct injection of PPIs
  KVM: arm64: gic-v5: Finalize GICv5 PPIs and generate mask
  KVM: arm64: gic: Introduce queue_irq_unlock to irq_ops
  KVM: arm64: gic-v5: Implement PPI interrupt injection
  KVM: arm64: gic-v5: Init Private IRQs (PPIs) for GICv5
  KVM: arm64: gic-v5: Check for pending PPIs
  KVM: arm64: gic-v5: Trap and mask guest ICC_PPI_ENABLERx_EL1 writes
  KVM: arm64: gic-v5: Support GICv5 interrupts with KVM_IRQ_LINE
  KVM: arm64: gic-v5: Create and initialise vgic_v5
  KVM: arm64: gic-v5: Reset vcpu state
  KVM: arm64: gic-v5: Bump arch timer for GICv5
  KVM: arm64: gic-v5: Mandate architected PPI for PMU emulation on GICv5
  KVM: arm64: gic: Hide GICv5 for protected guests
  KVM: arm64: gic-v5: Hide FEAT_GCIE from NV GICv5 guests
  KVM: arm64: gic-v5: Introduce kvm_arm_vgic_v5_ops and register them
  KVM: arm64: gic-v5: Set ICH_VCTLR_EL2.En on boot
  irqchip/gic-v5: Check if impl is virt capable
  KVM: arm64: gic-v5: Probe for GICv5 device
  Documentation: KVM: Introduce documentation for VGICv5
  KVM: arm64: selftests: Introduce a minimal GICv5 PPI selftest
  KVM: arm64: gic-v5: Communicate userspace-driveable PPIs via a UAPI

 Documentation/virt/kvm/api.rst                |   6 +-
 .../virt/kvm/devices/arm-vgic-v5.rst          |  50 ++
 Documentation/virt/kvm/devices/index.rst      |   1 +
 Documentation/virt/kvm/devices/vcpu.rst       |   5 +-
 arch/arm64/include/asm/el2_setup.h            |   3 +-
 arch/arm64/include/asm/kvm_asm.h              |   4 +
 arch/arm64/include/asm/kvm_host.h             |  35 ++
 arch/arm64/include/asm/kvm_hyp.h              |   9 +
 arch/arm64/include/asm/sysreg.h               |  28 +-
 arch/arm64/include/asm/vncr_mapping.h         |   3 +
 arch/arm64/include/uapi/asm/kvm.h             |   1 +
 arch/arm64/kvm/arch_timer.c                   | 118 +++-
 arch/arm64/kvm/arm.c                          |  40 +-
 arch/arm64/kvm/config.c                       | 147 ++++-
 arch/arm64/kvm/emulate-nested.c               | 123 +++-
 arch/arm64/kvm/hyp/include/hyp/switch.h       |  27 +
 arch/arm64/kvm/hyp/nvhe/Makefile              |   2 +-
 arch/arm64/kvm/hyp/nvhe/hyp-main.c            |  32 +
 arch/arm64/kvm/hyp/nvhe/switch.c              |  15 +
 arch/arm64/kvm/hyp/nvhe/sys_regs.c            |   8 +
 arch/arm64/kvm/hyp/vgic-v3-sr.c               |  69 +--
 arch/arm64/kvm/hyp/vgic-v5-sr.c               | 120 ++++
 arch/arm64/kvm/hyp/vhe/Makefile               |   2 +-
 arch/arm64/kvm/nested.c                       |   5 +
 arch/arm64/kvm/pmu-emul.c                     |  20 +-
 arch/arm64/kvm/sys_regs.c                     | 100 +++-
 arch/arm64/kvm/vgic/vgic-init.c               | 128 ++--
 arch/arm64/kvm/vgic/vgic-kvm-device.c         | 100 +++-
 arch/arm64/kvm/vgic/vgic-mmio.c               |  28 +-
 arch/arm64/kvm/vgic/vgic-v3-nested.c          |   8 +-
 arch/arm64/kvm/vgic/vgic-v3.c                 |  48 +-
 arch/arm64/kvm/vgic/vgic-v5.c                 | 552 +++++++++++++++++-
 arch/arm64/kvm/vgic/vgic.c                    | 106 +++-
 arch/arm64/kvm/vgic/vgic.h                    |  48 +-
 arch/arm64/tools/sysreg                       | 482 ++++++++++++++-
 drivers/irqchip/irq-gic-v5-irs.c              |   4 +
 drivers/irqchip/irq-gic-v5.c                  |  10 +
 include/kvm/arm_arch_timer.h                  |  11 +-
 include/kvm/arm_pmu.h                         |   5 +-
 include/kvm/arm_vgic.h                        | 142 ++++-
 include/linux/irqchip/arm-gic-v5.h            |  39 ++
 include/linux/kvm_host.h                      |   1 +
 include/uapi/linux/kvm.h                      |   2 +
 tools/arch/arm64/include/uapi/asm/kvm.h       |   1 +
 tools/include/uapi/linux/kvm.h                |   2 +
 tools/testing/selftests/kvm/Makefile.kvm      |   1 +
 tools/testing/selftests/kvm/arm64/vgic_v5.c   | 220 +++++++
 .../selftests/kvm/include/arm64/gic_v5.h      | 148 +++++
 48 files changed, 2774 insertions(+), 285 deletions(-)

----------------------------------------------------------------------

New:  LoongArch: KVM: Code cleanup about feature detect
[PATCH 0/4] LoongArch: KVM: Code cleanup about feature detect
Author: Bibo Mao <maobibo@loongson.cn>

Here is code cleanup about feature detection, there is feature
initialization about host machine, feature checking about VM and host.

Also add register LOONGARCH_CSR_IPR during vCPU context switch, though
it is not used by msgint driver now, it is defined by HW and may be used
in future.

Bibo Mao (4):
  LoongArch: KVM: Move feature detection in function
    kvm_vm_init_features
  LoongArch: KVM: Add msgint registers in function kvm_init_gcsr_flag
  LoongArch: KVM: Check VM msgint feature during interrupt handling
  LoongArch: KVM: Add register LOONGARCH_CSR_IPR during vCPU context
    switch

 arch/loongarch/include/asm/kvm_host.h  |  5 ++++
 arch/loongarch/include/asm/loongarch.h |  2 +-
 arch/loongarch/kvm/interrupt.c         |  4 +--
 arch/loongarch/kvm/main.c              |  8 ++++++
 arch/loongarch/kvm/vcpu.c              |  6 +++--
 arch/loongarch/kvm/vm.c                | 36 +++++++++++---------------
 6 files changed, 35 insertions(+), 26 deletions(-)

----------------------------------------------------------------------

New:  LoongArch: KVM: Move feature detection in function kvm_vm_init_features
[PATCH 1/4] LoongArch: KVM: Move feature detection in function kvm_vm_init_features
Author: Bibo Mao <maobibo@loongson.cn>

VM feature detection is sparsed in function kvm_vm_init_features()
and kvm_vm_feature_has_attr(). Here move all the feature detection
in function kvm_vm_init_features(), and there is only feature checking
in function kvm_vm_feature_has_attr().

Signed-off-by: Bibo Mao <maobibo@loongson.cn>
---
 arch/loongarch/kvm/vm.c | 36 +++++++++++++++---------------------
 1 file changed, 15 insertions(+), 21 deletions(-)

----------------------------------------------------------------------

New:  KVM: x86: Explicitly configure supported XSS from {svm,vmx}_set_cpu_caps()
[PATCH v2 1/3] KVM: x86: Explicitly configure supported XSS from {svm,vmx}_set_cpu_caps()
Author: Sean Christopherson <seanjc@google.com>

Explicitly configure KVM's supported XSS as part of each vendor's setup
flow to fix a bug where clearing SHSTK and IBT in kvm_cpu_caps, e.g. due
to lack of CET XFEATURE support, makes kvm-intel.ko unloadable when nested
VMX is enabled, i.e. when nested=1.  The late clearing results in
nested_vmx_setup_{entry,exit}_ctls() clearing VM_{ENTRY,EXIT}_LOAD_CET_STATE
when nested_vmx_setup_ctls_msrs() runs during the CPU compatibility checks,
ultimately leading to a mismatched VMCS config due to the reference config
having the CET bits set, but every CPU's "local" config having the bits
cleared.

Note, kvm_caps.supported_{xcr0,xss} are unconditionally initialized by
kvm_x86_vendor_init(), before calling into vendor code, and not referenced
between ops->hardware_setup() and their current/old location.

Fixes: 69cc3e886582 ("KVM: x86: Add XSS support for CET_KERNEL and CET_USER")
Cc: stable@vger.kernel.org
Cc: Mathias Krause <minipli@grsecurity.net>
Cc: John Allen <john.allen@amd.com>
Cc: Rick Edgecombe <rick.p.edgecombe@intel.com>
Cc: Chao Gao <chao.gao@intel.com>
Cc: Binbin Wu <binbin.wu@linux.intel.com>
Cc: Xiaoyao Li <xiaoyao.li@intel.com>
Signed-off-by: Sean Christopherson <seanjc@google.com>
---
 arch/x86/kvm/svm/svm.c |  2 ++
 arch/x86/kvm/vmx/vmx.c |  2 ++
 arch/x86/kvm/x86.c     | 30 +++++++++++++++++-------------
 arch/x86/kvm/x86.h     |  2 ++
 4 files changed, 23 insertions(+), 13 deletions(-)

----------------------------------------------------------------------

New:  KVM: x86: CET vs. nVMX fix and hardening
[PATCH v2 0/3] KVM: x86: CET vs. nVMX fix and hardening
Author: Sean Christopherson <seanjc@google.com>

Fix a bug where KVM will clear IBT and SHSTK bits after nested VMX MSRs
have been configured, e.g. if the kernel is built with CONFIG_X86_CET=y
but CONFIG_X86_KERNEL_IBT=n.  The late clearing results in kvm-intel.ko
refusing to load as the CPU compatible checks generate their VMCS configs
with IBT=n and SHSTK=n, ultimately causing a mismatch on the CET entry
and exit controls.

Patch 2 hardens against similar bugs in the future by adding a flag and
WARNs to yell if KVM sets or clear feature flags outside of the dedicated
flow.

Patch 3 adds (very, very) long overdue printing of the mistmatching offsets
in the VMCS configs.

Chao, I didn't include any of your Reviewed-by's, as every patch changed
quite a bit from v1.

v2:
 - Isolate kvm_setup_xss_caps() from kvm_finalize_cpu_caps(). [Xiaoyao]
 - Fix the pr_cont() printing. [Chao]

v1: https://lore.kernel.org/all/20260123221542.2498217-1-seanjc@google.com

Sean Christopherson (3):
  KVM: x86: Explicitly configure supported XSS from
    {svm,vmx}_set_cpu_caps()
  KVM: x86: Harden against unexpected adjustments to kvm_cpu_caps
  KVM: VMX: Print out "bad" offsets+value on VMCS config mismatch

 arch/x86/kvm/cpuid.c   | 10 ++++++++--
 arch/x86/kvm/cpuid.h   | 12 +++++++++++-
 arch/x86/kvm/svm/svm.c |  6 +++++-
 arch/x86/kvm/vmx/vmx.c | 23 +++++++++++++++++++++--
 arch/x86/kvm/x86.c     | 30 +++++++++++++++++-------------
 arch/x86/kvm/x86.h     |  2 ++
 6 files changed, 64 insertions(+), 19 deletions(-)

----------------------------------------------------------------------

New:  KVM: x86: Defer IBPBs for vCPU and nested transitions
[PATCH 1/2] KVM: x86: Defer IBPBs for vCPU and nested transitions
Author: Sean Christopherson <seanjc@google.com>

When emitting an Indirect Branch Prediction Barrier to isolate different
guest security domains (different vCPUs or L1 vs. L2 in the same vCPU),
defer the IBPB until VM-Enter is imminent to avoid redundant and/or
unnecessary IBPBs.  E.g. if a vCPU is loaded on a CPU without ever doing
VM-Enter, then _KVM_ isn't responsible for doing an IBPB as KVM's job is
purely to mitigate guests<=>guest attacks; guest=>host attacks are covered
by IBRS.

Cc: stable@vger.kernel.org
Cc: Yosry Ahmed <yosry.ahmed@linux.dev>
Cc: Jim Mattson <jmattson@google.com>
Cc: David Kaplan <david.kaplan@amd.com>
Signed-off-by: Sean Christopherson <seanjc@google.com>
---
 arch/x86/include/asm/kvm_host.h | 1 +
 arch/x86/kvm/x86.c              | 7 ++++++-
 arch/x86/kvm/x86.h              | 2 +-
 3 files changed, 8 insertions(+), 2 deletions(-)

----------------------------------------------------------------------

New:  KVM: x86: Plug an intra-guest Spectre v2 hole
[PATCH 0/2] KVM: x86: Plug an intra-guest Spectre v2 hole
Author: Sean Christopherson <seanjc@google.com>

Fix a bug where KVM neglects to emit IBPB when a vCPU is migrated *back* to
a previous pCPU, in which case a misbehaving task B in the guest can unduly
infuence e.g. the BTB of task A in the guest (running in the same vCPU).

FWIW, I've had the first patch sitting around for several months as a
micro-optimization, but was never posted it as I wasn't 100% confident my
analysis was correct.  But it makes plugging this hole much easier, so here
it is...  Reviews most definitely welcome.

Sean Christopherson (2):
  KVM: x86: Defer IBPBs for vCPU and nested transitions until core run
    loop
  KVM: x86: Emit IBPB on pCPU migration if IBPB is advertised to guest

 arch/x86/include/asm/kvm_host.h |  1 +
 arch/x86/kvm/x86.c              | 20 +++++++++++++++++++-
 arch/x86/kvm/x86.h              |  2 +-
 3 files changed, 21 insertions(+), 2 deletions(-)

----------------------------------------------------------------------

